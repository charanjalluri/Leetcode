# **Leetcode Problem #169 - Majority Element**  

## **ğŸ“Œ Problem Statement**  
Given an array `nums` of size `n`, return the **majority element**.  
The majority element is the element that **appears more than** `âŒŠn / 2âŒ‹` times.  
You may assume that the majority element **always exists** in the array.  

### **ğŸ”¹ Example 1:**  
```python
Input: nums = [3, 2, 3]  
Output: 3  
```

### **ğŸ”¹ Example 2:**  
```python
Input: nums = [2, 2, 1, 1, 1, 2, 2]  
Output: 2  
```

---

## **ğŸš€ Solution Approach (Boyer-Moore Voting Algorithm)**  
The **Boyer-Moore Voting Algorithm** efficiently finds the majority element in `O(n)` time and `O(1)` space.  

**Steps:**  
1. Maintain a **count** and a **candidate element**.  
2. Iterate through the array:  
   - If `count == 0`, set the current number as **candidate**.  
   - If the current number is the same as the candidate, **increase** count.  
   - Otherwise, **decrease** count.  
3. The candidate at the end is the **majority element**.  

---

## **ğŸ“ Optimized Python Solution**  
```python
class Solution:
    def majorityElement(self, nums):
        count = 0
        candidate = None

        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)

        return candidate

# Example usage:
sol = Solution()
print(sol.majorityElement([3, 2, 3]))  # Output: 3
print(sol.majorityElement([2, 2, 1, 1, 1, 2, 2]))  # Output: 2
```

---

## **â³ Time & Space Complexity**  
âœ… **Time Complexity:** `O(n)`, single pass through the array.  
âœ… **Space Complexity:** `O(1)`, no extra space used.  

---
---

## **â­ Follow for More**  
If you found this helpful, **â­ star** the repo and follow me on GitHub! ğŸš€ğŸ˜Š  

---
